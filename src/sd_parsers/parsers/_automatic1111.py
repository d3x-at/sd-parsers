"""Parser for images generated by AUTOMATIC1111's stable-diffusion-webui or similar."""
import json
import re
from contextlib import suppress
from typing import Any, Dict

from PIL.Image import Image
from PIL.PngImagePlugin import PngImageFile

from .._exceptions import ParserError
from .._models import Model, Prompt, Sampler
from .._parser import Generators, Parser, ParseResult, get_exif_value, pop_keys
from .._prompt_info import PromptInfo
from ._managed_parsers import MANAGED_PARSERS

SAMPLER_PARAMS = ["Sampler", "CFG scale", "Seed", "Steps", "ENSD"]


class AUTOMATIC1111Parser(Parser):
    """parse images created in AUTOMATIC1111's webui"""

    @property
    def generator(self):
        return Generators.AUTOMATIC1111

    def read_parameters(self, image: Image):
        if isinstance(image, PngImageFile):
            try:
                parameters = image.text["parameters"]
            except KeyError as error:
                return None, error

            return PromptInfo(self, {"parameters": parameters}), None

        if image.format in ("JPEG", "WEBP"):
            try:
                parameters = get_exif_value(image, "UserComment")
            except (KeyError, ValueError) as error:
                return None, error

            return PromptInfo(self, {"parameters": parameters}), None

        return None, None

    def parse(self, parameters: Dict[str, Any]) -> ParseResult:
        try:
            lines = parameters["parameters"].split("\n")
        except (KeyError, ValueError) as error:
            raise ParserError("error reading parameter string") from error

        info_index, sampler_info, metadata = get_sampler_info(lines)
        prompts = "\n".join(lines[:info_index]).split("Negative prompt:")
        prompt, negative_prompt = map(str.strip, prompts + [""] * (2 - len(prompts)))

        try:
            sampler = Sampler(
                name=sampler_info.pop("Sampler"),
                parameters=self.normalize_parameters(sampler_info),
            )
        except KeyError as error:
            raise ParserError("no sampler found") from error

        model_name = metadata.pop("Model", None)
        model_hash = metadata.pop("Model hash", None)
        if model_name or model_hash:
            sampler.model = Model(
                name=model_name,
                model_hash=model_hash,
            )

        if prompt:
            sampler.prompts.append(Prompt(prompt))

        if negative_prompt:
            sampler.negative_prompts.append(Prompt(negative_prompt))

        metadata = self.normalize_parameters(metadata)

        return [sampler], metadata


def get_sampler_info(lines):
    def split_meta(line: str) -> Dict[str, str]:
        # try to extract civitai hashes
        civitai_hashes = None
        match = re.search(r"(?:,\s*)?Hashes:\s*(\{[^\}]*\})\s*", line)
        if match:
            with suppress(json.JSONDecodeError):
                civitai_hashes = json.loads(match.group(1))
            start, end = match.span(0)
            line = line[:start] + line[end:]

        metadata = {}
        for item in line.split(","):
            try:
                key, value = map(str.strip, item.split(":"))
                metadata[key] = value
            except ValueError:
                pass

        if civitai_hashes:
            metadata["civitai_hashes"] = civitai_hashes

        return metadata

    for index, line in reversed(list(enumerate(lines))):
        metadata = split_meta(line)
        sampler_info = dict(pop_keys(SAMPLER_PARAMS, metadata))
        if len(sampler_info) >= 3:
            return index, sampler_info, metadata

    raise ParserError("no sampler information found")


MANAGED_PARSERS.append(AUTOMATIC1111Parser)
