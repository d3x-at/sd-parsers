"""Parser for images generated by AUTOMATIC1111's stable-diffusion-webui or similar."""

import json
import re
from contextlib import suppress
from typing import Any, Dict

from sd_parsers.data import Generators, Model, Prompt, Sampler, PromptInfo
from sd_parsers.exceptions import ParserError

from ._parser import Parser, ReplacementRules, pop_keys

SAMPLER_PARAMS = ["Sampler", "CFG scale", "Seed", "Steps", "ENSD", "Schedule type"]

REPLACEMENT_RULES: ReplacementRules = [("Schedule type", "scheduler")]


class AUTOMATIC1111Parser(Parser):
    """parse images created in AUTOMATIC1111's webui"""

    generator = Generators.AUTOMATIC1111

    def parse(self, parameters: Dict[str, Any]) -> PromptInfo:
        try:
            lines = parameters["parameters"].split("\n")
        except (KeyError, ValueError, AttributeError) as error:
            raise ParserError("error reading parameter string") from error

        info_index, sampler_info, metadata = _get_sampler_info(lines)
        prompts = "\n".join(lines[:info_index]).split("Negative prompt:")
        prompt, negative_prompt = map(str.strip, prompts + [""] * (2 - len(prompts)))

        try:
            sampler = {
                "name": sampler_info.pop("Sampler"),
                "parameters": self.normalize_parameters(sampler_info, REPLACEMENT_RULES),
            }
        except KeyError as error:
            raise ParserError("no sampler found") from error

        model_name = metadata.pop("Model", None)
        model_hash = metadata.pop("Model hash", None)

        if model_name or model_hash:
            sampler["model"] = Model(
                name=model_name,
                hash=model_hash,
            )

        if prompt:
            sampler["prompts"] = [Prompt(prompt)]

        if negative_prompt:
            sampler["negative_prompts"] = [Prompt(negative_prompt)]

        return PromptInfo(self.generator, [Sampler(**sampler)], metadata, parameters)


def _get_sampler_info(lines):
    for index, line in reversed(list(enumerate(lines))):
        metadata = _extract_metadata(line)
        sampler_info = dict(pop_keys(SAMPLER_PARAMS, metadata))
        if len(sampler_info) >= 3:
            return index, sampler_info, metadata

    raise ParserError("no sampler information found")


def _extract_metadata(line: str) -> Dict[str, str]:
    metadata = {}

    # try to extract hashes
    match = re.search(r"(?:,\s*)?Hashes:\s*(\{[^\}]*\})\s*", line)
    if match:
        with suppress(TypeError, json.JSONDecodeError):
            metadata["Hashes"] = json.loads(match.group(1))
        start, end = match.span(0)
        line = line[:start] + line[end:]

    for item in line.split(","):
        try:
            key, value = map(str.strip, item.split(":"))
            metadata[key] = value
        except ValueError:
            pass

    return metadata
